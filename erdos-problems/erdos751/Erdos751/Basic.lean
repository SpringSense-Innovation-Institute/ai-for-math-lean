import Mathlib.Combinatorics.SimpleGraph.Paths
import Mathlib.Combinatorics.SimpleGraph.Connectivity.Connected
import Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph
import Mathlib.Combinatorics.SimpleGraph.Subgraph
import Mathlib.Combinatorics.SimpleGraph.Trails
import Mathlib.Combinatorics.SimpleGraph.Ends.Defs
import Mathlib.Data.Nat.Find
import Mathlib.Data.Finset.Card
import Mathlib.Tactic


namespace Erdos751

open Classical

universe u
variable {V : Type u} [Fintype V] [DecidableEq V]
variable (G : SimpleGraph V) [DecidableRel G.Adj]

namespace BV

/-- Paper-cycle: based closed walk + IsCycle + explicit length ≥ 3. -/
structure Cycle where
  base : V
  walk : G.Walk base base
  isCycle : walk.IsCycle
  len_ge_three : 3 ≤ walk.length

namespace Cycle

/-- Length of a cycle as walk length. -/
def length (C : Cycle (G := G)) : Nat := C.walk.length

/-- Vertex finset of a cycle (support of the walk). -/
noncomputable def verts (C : Cycle (G := G)) : Finset V := by
  classical
  exact C.walk.support.toFinset

/-- Vertex set of a cycle. -/
def vSet (C : Cycle (G := G)) : Set V := fun v => v ∈ C.verts (G := G)

omit [Fintype V] [DecidableRel G.Adj] in
lemma mem_vSet_iff {C : Cycle (G := G)} {v : V} :
    v ∈ C.vSet (G := G) ↔ v ∈ C.verts (G := G) := Iff.rfl

/-- The subgraph generated by the walk. -/
noncomputable def toSubgraph (C : Cycle (G := G)) : G.Subgraph := by
  classical
  exact C.walk.toSubgraph

/-- A chord: an edge of G between cycle vertices not present in the walk-subgraph. -/
def IsChord (C : Cycle (G := G)) (v w : V) : Prop :=
  v ∈ C.vSet (G := G) ∧
  w ∈ C.vSet (G := G) ∧
  G.Adj v w ∧
  ¬ (C.toSubgraph (G := G)).Adj v w

/-- Chordless/induced cycle: no chord exists. -/
def IsChordless (C : Cycle (G := G)) : Prop :=
  ¬ ∃ v w : V, C.IsChord (G := G) v w

end Cycle

/-! ### BV-level hypotheses (single source of truth) -/

/-- Vertex-two-connected interface (delete any vertex keeps connected). -/
def VertexTwoConnected : Prop :=
  G.Connected ∧ ∀ v : V, (G.induce (fun w : V => w ≠ v)).Connected

/-- Minimum degree ≥ 3. -/
def MinDegreeGE3 : Prop := ∀ v : V, 3 ≤ G.degree v

/-- Minimum degree ≥ 2 (used for cycle existence). -/
def MinDegreeGE2 : Prop := ∀ v : V, 2 ≤ G.degree v

/-
Bridges.

We use `ComponentCompl` to model connected components of the complement of the cycle-vertex set.
Avoid coercions / `.supp` outside this file: define `bridgeSet` as the stable API.
-/

/-- Component-bridge: connected component of the complement of `C.vSet`. -/
abbrev Bridge (C : Cycle (G := G)) : Type _ :=
  G.ComponentCompl (C.vSet (G := G))

/-! `bridgeSet` is the only API for bridge carriers (avoid `.supp` entirely). -/
def bridgeSet (C : Cycle (G := G)) (K : Bridge (G := G) C) : Set V := (K : Set V)

omit [Fintype V] [DecidableRel G.Adj] in
@[simp] lemma mem_bridgeSet_iff {C : Cycle (G := G)} {K : Bridge (G := G) C} {v : V} :
    v ∈ bridgeSet (G := G) C K ↔ v ∈ (K : Set V) := Iff.rfl

omit [Fintype V] [DecidableRel G.Adj] in
theorem bridgeSet_subset_compl_vSet
    (C : Cycle (G := G)) (K : Bridge (G := G) C) :
    bridgeSet (G := G) C K ⊆ (C.vSet (G := G))ᶜ := by
  classical
  intro v hv
  -- hv : v ∈ bridgeSet C K = v ∈ (K : Set V)
  have hvK : v ∈ (K : Set V) := by
    simpa [bridgeSet] using hv
  have hnot : v ∉ C.vSet (G := G) := by
    -- `v` 在该 lemma 里是隐式参数；显式给 `v := v` 最稳
    exact SimpleGraph.ComponentCompl.notMem_of_mem
      (G := G) (K := C.vSet (G := G)) (C := K) (c := v) hvK
  simpa [Set.mem_compl_iff] using hnot


/-- Internal vertices of a bridge as a finset. -/
noncomputable def internalFinset (C : Cycle (G := G)) (K : Bridge (G := G) C) : Finset V := by
  classical
  exact (bridgeSet (G := G) C K).toFinset

/-- Internal cardinality of a bridge component. -/
noncomputable def internalCard (C : Cycle (G := G)) (K : Bridge (G := G) C) : Nat :=
  (internalFinset (G := G) C K).card

/-- Attachment set: cycle vertices adjacent to some vertex in the bridge. -/
def attachSet (C : Cycle (G := G)) (K : Bridge (G := G) C) : Set V :=
  fun x : V =>
    x ∈ C.vSet (G := G) ∧ ∃ w : V, w ∈ bridgeSet (G := G) C K ∧ G.Adj x w

/-- Predicate for `findGreatest`: some bridge has internalCard = n. -/
def Pbridge (C : Cycle (G := G)) (n : Nat) : Prop :=
  ∃ K : Bridge (G := G) C, internalCard (G := G) C K = n

/-- M(C): max internalCard among bridges (using card V as a uniform bound). -/
noncomputable def M (C : Cycle (G := G)) : Nat := by
  classical
  exact Nat.findGreatest (Pbridge (G := G) C) (Fintype.card V)

/-- Pcycle n: there exists a chordless cycle with M(C)=n. -/
def Pcycle (n : Nat) : Prop :=
  ∃ C : Cycle (G := G), C.IsChordless (G := G) ∧ M (G := G) C = n

omit [DecidableRel G.Adj] in
/-- Crude bound: internalCard ≤ card V. -/
theorem internalCard_le_cardV (C : Cycle (G := G)) (K : Bridge (G := G) C) :
    internalCard (G := G) C K ≤ Fintype.card V := by
  classical
  simpa [internalCard, internalFinset] using
    (Finset.card_le_univ (s := (bridgeSet (G := G) C K).toFinset))

omit [DecidableRel G.Adj] in
/-- Bound: M(C) ≤ card V. -/
theorem M_le_cardV (C : Cycle (G := G)) : M (G := G) C ≤ Fintype.card V := by
  classical
  simpa [M] using
    (Nat.findGreatest_le (P := Pbridge (G := G) C) (n := Fintype.card V))

omit [DecidableRel G.Adj] in
/-- Witness for `Pcycle`: from a chordless cycle we get some `n ≤ card V` with `Pcycle n`. -/
theorem exists_Pcycle_of_exists_chordless
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) :
    ∃ n : Nat, n ≤ Fintype.card V ∧ Pcycle (G := G) n := by
  classical
  rcases hch with ⟨C, hC⟩
  refine ⟨M (G := G) C, M_le_cardV (G := G) C, ?_⟩
  exact ⟨C, hC, rfl⟩

/-- nMax: global max value of M(C) among chordless cycles, needs an explicit seed witness. -/
noncomputable def nMax
    (_hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) : Nat := by
  classical
  exact Nat.findGreatest (Pcycle (G := G)) (Fintype.card V)

omit [DecidableRel G.Adj] in
/-- Pcycle holds at nMax (spec lemma; proof filled later). -/
theorem Pcycle_nMax
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) :
    Pcycle (G := G) (nMax (G := G) hch) := by
  classical
  rcases exists_Pcycle_of_exists_chordless (G := G) hch with ⟨n, hnle, hnP⟩
  simpa [nMax] using
    (Nat.findGreatest_spec (P := Pcycle (G := G)) (m := n)
      (n := Fintype.card V) hnle hnP)

/-- Choose Cmax: a chordless cycle attaining nMax. -/
noncomputable def Cmax
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) : Cycle (G := G) :=
  Classical.choose (Pcycle_nMax (G := G) hch)

omit [DecidableRel G.Adj] in
theorem Cmax_isChordless
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) :
    (Cmax (G := G) hch).IsChordless (G := G) := by
  classical
  exact (Classical.choose_spec (Pcycle_nMax (G := G) hch)).1

omit [DecidableRel G.Adj] in
theorem M_Cmax_eq_nMax
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G)) :
    M (G := G) (Cmax (G := G) hch) = nMax (G := G) hch := by
  classical
  exact (Classical.choose_spec (Pcycle_nMax (G := G) hch)).2

omit [Fintype V] [DecidableRel G.Adj] in
/-- Nonempty bridge ↔ there exists a vertex outside the cycle vertex-set. -/
theorem nonempty_bridge_iff_exists_outside
    (C : Cycle (G := G)) :
    Nonempty (Bridge (G := G) C) ↔ ∃ v : V, v ∉ C.vSet (G := G) := by
  classical
  constructor
  · rintro ⟨K⟩
    rcases (SimpleGraph.ComponentCompl.nonempty (C := K)) with ⟨v, hv⟩
    have hnot : v ∉ C.vSet (G := G) :=
      SimpleGraph.ComponentCompl.notMem_of_mem
        (G := G) (K := C.vSet (G := G)) (C := K) (c := v) hv
    exact ⟨v, hnot⟩
  · rintro ⟨v, hv⟩
    exact ⟨G.componentComplMk (K := C.vSet (G := G)) hv⟩

omit [DecidableRel G.Adj] in
/-- Existence of a bridge attaining M(C), assuming nonemptiness. -/
theorem exists_bridge_attaining_M_of_nonempty
    (C : Cycle (G := G)) (hne : Nonempty (Bridge (G := G) C)) :
    ∃ K : Bridge (G := G) C, internalCard (G := G) C K = M (G := G) C := by
  classical
  rcases hne with ⟨K0⟩
  have hP : Pbridge (G := G) C (internalCard (G := G) C K0) := ⟨K0, rfl⟩
  have hle : internalCard (G := G) C K0 ≤ Fintype.card V :=
    internalCard_le_cardV (G := G) C K0
  have hPmax : Pbridge (G := G) C (M (G := G) C) := by
    simpa [M] using
      (Nat.findGreatest_spec (P := Pbridge (G := G) C) (m := internalCard (G := G) C K0)
        (n := Fintype.card V) hle hP)
  rcases hPmax with ⟨K, hK⟩
  exact ⟨K, hK⟩

/-- Choose Bmax for Cmax, but only with explicit `Nonempty (Bridge (Cmax ...))`. -/
noncomputable def Bmax
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G))
    (hne : Nonempty (Bridge (G := G) (Cmax (G := G) hch))) :
    Bridge (G := G) (Cmax (G := G) hch) :=
  Classical.choose
    (exists_bridge_attaining_M_of_nonempty (G := G) (Cmax (G := G) hch) hne)

omit [DecidableRel G.Adj] in
theorem internalCard_Bmax_eq_M
    (hch : ∃ C : Cycle (G := G), C.IsChordless (G := G))
    (hne : Nonempty (Bridge (G := G) (Cmax (G := G) hch))) :
    internalCard (G := G) (Cmax (G := G) hch) (Bmax (G := G) hch hne)
      = M (G := G) (Cmax (G := G) hch) := by
  classical
  exact (Classical.choose_spec
    (exists_bridge_attaining_M_of_nonempty (G := G) (Cmax (G := G) hch) hne))

end BV
end Erdos751
